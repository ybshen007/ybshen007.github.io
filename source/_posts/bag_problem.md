---
layout:     post
title:      "背包问题"
subtitle:   "0-1背包问题、完全背包问题"
date:       2018-09-24
author:     "ShiLou"
catalog: true
tags:
    - 背包问题
    - dp
    - 算法
---

> 背包问题详解，如何用滚动数组优化空间复杂度。  
<!-- more -->
  


## 1. 0-1背包问题  
**问题描述：** 有n个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？  
  
**思路:** 首先定义物品的价值数组$v[n]$以及重量数组$w[n]$，以$dp[i][j]$表示**背包容量为j**时**前i个**物品的最大价值。假设已知前i-1个物品的最大价值$dp[i-1][j]$，则前i个商品最大价值取法有两种情况：  
1）对第i个物品，其重量$w[i]>j$，则物品i无法被加到背包中，此时，$dp[i][j] = dp[i]$。
2）对第i个物品，其重量$w[i]<=j$，则物品i可以加到背包中，此时面临是否将其加入到背包中的决策：  
　　a.不加入，则$dp[i][j] = dp[i-1][j]$  
　　b.加入，则$dp[i][j] = dp[i-1][j-w[i]] + v[i]$  
  
其中$dp[i-1][j-w[i]]$表示在背包容量为$j-w[i]$（去除商品i后还允许的重量）下，前i-1个商品的最大价值。由此:  

$$dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])$$  

ps. 对于上述情形2，取最大价值时会有加入/不加入两种情形的原因：  
直觉上，当能加入物品i时就把它加进去，价值一定会变大。但要注意的是，$dp[i][j]$定义的是背包**总容量**为j时前i个物品的最大价值，而不是背包**剩余容量**为j时。也就是说，把物品i加入背包是有代价的，代价是背包的容量减少了$w[i]$。那么之前已经在背包中的物品重量和可能会超过背包容量，因此此时要比较加入物品i能不能最大化价值。举例来说，背包中已有1个物品，价值为3，重量为3，背包总容量为4。即$dp[1][4]=3$，$dp[1][0]=0$。此时对第2a、2b个物品产生决策，若物品2a价值2，重量4，物品2b价值4，重量4。则如果把物品2a加入到背包中，需要把物品1替换，总价值反而减少成为了2。因此决策结果是不放入，而对于物品2b，决策结果是用物品2b替换物品2。  
2a: $dp[2a][4] = max(dp[1][4], dp[1][4-4]+v[2a]) = max(3, 2)$
2b: $dp[2b][4] = max(dp[1][4], dp[1][4-4]+v[2b]) = max(3, 4)$  

```c++
int bag(vector<int> weights, vector<int> values, int sum) {
    int dp[values.size()+1][sum+1];
    for (int i = 0; i <= sum; ++i) {
        dp[0][i] = 0;
    }
    for (int i = 1; i <= values.size(); ++i) {
        dp[i][0] = 0;
    }
    for (int i = 1; i <= values.size(); ++i) {
        for (int j = 1; j <= sum; ++j) {
            if (j < weights[i-1]) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1]);
            }
        }
    }
    return dp[values.size()][sum];
}
```

对于weights: {2,3,4,5}，values: {3,4,5,6}，容量8，有输出dp矩阵：  

```
i/j 0 1 2 3 4 5 6 7 8
 0  0 0 0 0 0 0 0 0 0
 1  0 0 3 3 3 3 3 3 3
 2  0 0 3 4 4 7 7 7 7
 3  0 0 3 4 5 7 8 9 9
 4  0 0 3 4 5 7 8 9 10
```
以上代码得到的是最大价值，如果要得到所有所选商品，可以从最后一个商品n开始回溯。如果$dp[i][j]=dp[i-1][j]$，表明当前第i个商品未加入背包，回到$dp[i-1][j]$，否则表明该商品在背包中，可以根据公式$dp[i][j]=dp[i-1][j-[w[i]]+v[i]$回溯到$dp[i-1][j-w[i]]$  

上述解法时间和空间复杂度都为$O(nV)$，$n$和$V$分别为物品总数和背包容量。 其中空间复杂度还可以优化到$O(V)$，利用滚动数组。状态方程为  

$$dp[j]=dp[j-w[i]]+v[i]$$  
  
```c++
int bag(vector<int> weights, vector<int> values, int capacity) {
    int dp[capacity+1];
    for (int i = 0; i <= capacity; ++i) {
        dp[i] = 0;
    }
    for (int i = 1; i <= values.size(); ++i) {
        for (int j = capacity; j >= weights[i-1] ; --j) {
            dp[j] = max(dp[j], dp[j-weights[i-1]]+values[i-1]);
        }
    }
    return dp[capacity];
```

**注意：遍历容量j时，要倒序遍历。**  
原因：在更新第i个物品时，依赖$dp[i-1][j-w[i]]$这一项，因此要保证这一项只包含了前i-1个物品的情况。如果先更新了这一项，则此时背包中可能已经存在第i个物品，导致重复计算。  
举例来说，设第2个物品重量为2，价值为3。背包目前为空。如果顺序更新，更新$dp[2]$时有
$$dp[2]=max(dp[2], dp[2-2]+3)=3$$
背包中加入了物品2。更新$dp[4]$时有
$$dp[4]=max(dp[4], dp[4-2]+3)=6$$
物品2再次被加入到背包中，造成重复计算。  

## 2. 完全背包问题  

**问题描述：** 完全背包问题是指，每种物品不限个数，其余条件和0-1背包问题相同。  
**思路：** 和0-1背包问题相比，区别在于将第i个物品加入到背包中后，不需要转移到$dp[i-1][j-w[i]]$的状态，而是转移到$dp[i][j-w[i]]$的状态，因为第i个物品可以反复添加。因此转移方程为:  

$$dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i])$$

同样的，空间复杂度可以优化到$O(V)$，利用滚动数组得到的状态转移方程和0-1背包相同，为  

$$dp[j]=dp[j-w[i]]+v[i]$$

唯一不同之处在于，遍历容量j时要**正序**遍历，原因即上文所提，正序遍历时会包含重复计算已有物品，这正是完全背包问题需要的。